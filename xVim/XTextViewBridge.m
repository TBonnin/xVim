//
//  XTextViewB.m
//  xVim
//
//  Created by Morris on 12-2-28.
//  Copyright (c) 2012å¹´ __MyCompanyName__. All rights reserved.
//

#import "XGlobal.h"
#import "XTextViewBridge.h"
#import "XVimController.h"
#import "XVimMode.h"

// ========== XTextViewBridge ==========
@interface XTextViewBridge()
{
@private
    XVimController*     controller;
    __weak NSTextView*  targetView;
    __weak XCmdlineTextField* cmdline;
}

-(void) cmdlineLostFocus;
@end

@implementation XCmdlineTextField
-(BOOL) resignFirstResponder
{
    [(XTextViewBridge*)[self delegate] cmdlineLostFocus];
    return YES;
}

@end

@implementation XTextViewBridge

-(NSTextView*)     targetView    { return targetView; }
-(XVimController*) vimController { return controller; }

-(XTextViewBridge*) initWithTextView:(NSTextView*) view
{
    if (self = [super init]) {
        targetView = view; // Must assigned this before creating the XVimController.
        controller = [[XVimController alloc] initWithBridge:self];
    }
    return self;
}

-(void) dealloc  
{ 
    DLog(@"Deallocing XTexViewBridge: %@", self); 
    [controller release]; 
    [cmdline release];
}
-(void) finalize { DLog(@"XTextViewBridge Finalized"); [super finalize]; }
-(void) processKeyEvent:(NSEvent*)event { [controller processKeyEvent:event]; }
-(BOOL) closePopup { return NO; }

-(void) handleFakeKeyEvent:(NSEvent*) fakeEvent {
    
    // Give them a chance to cooperate with us
    if ([self->targetView respondsToSelector:@selector(handleVimKeyEvent:)]) {
        [self->targetView performSelector:@selector(handleVimKeyEvent:) withObject:fakeEvent];
    }
    // Pleading the 5th? Hit 'em with the swizzle stick. 
    else if (orig_keyDown) {
        orig_keyDown(self->targetView, @selector(keyDown:), fakeEvent);
    }
}

-(BOOL) ignoreString:(NSString*) string selection:(NSRange) range
{
    // In Xcode, the user can select a token which is generated by the editor
    // The selection will be a char an it's 0xFFFC
    return range.length == 1 && [string characterAtIndex:range.location] == 0xFFFC;
}

- (void)controlTextDidChange:(NSNotification*)obj
{
    NSTextView* field  = [[obj userInfo] objectForKey:@"NSFieldEditor"];
    NSString*   string = [field string];
    [[controller currentHandler] cmdlineTextChanged:string];    
}

- (BOOL)control:(NSControl *)control textView:(NSTextView *)textView doCommandBySelector:(SEL)command
{
    if (command == @selector(cancelOperation:))
    {
        [[controller currentHandler] cmdlineCanceled];
    } else if (command == @selector(insertNewline:))
    {
        [[controller currentHandler] cmdlineAccepted:textView];
    }
    return NO;
}

- (void)cmdlineLostFocus
{
    [cmdline setStringValue:@""];
    [[controller currentHandler] cmdlineCanceled];
}

- (void) setCmdlineTextField:(XCmdlineTextField *)tf
{
    if (cmdline) {
        [cmdline setDelegate:nil];
    }
    
    cmdline = tf;
    [cmdline setDelegate:self];
}

- (XCmdlineTextField*) cmdlineTextField
{
    return cmdline;
}

- (void) setModeTitle:(NSString*) modeTitle
{
    if (cmdline == nil) { return; }
}

- (void) setCmdString:(NSString*) cmd
{
    if (cmdline == nil) { return; }
    [cmdline setStringValue:cmd];
}

- (void) setFocusToCmdline
{
    if (cmdline == nil) { return; }
    [[cmdline window] makeFirstResponder:cmdline];
}
@end
